#include <stdio.h> //подключим библиотеку ввода и вывода
#include <stdlib.h> //подключим библиотеку с функцией модуля
#include <math.h> //подключим библиотеку с функцией квадратного корня

int max(int num_1, int num_2)
{
	if (num_1 >= num_2) {
		return num_1;
	} else {
		return num_2;
		}
}

int sign(int ch) //напишем функцию, при x > 0 она возвращает 1, при x = 0 возвращает 0, при x < 0 возвращает -1
{
	if (ch > 0) {
	return 1;
	}
	if (ch == 0) {
	return 0;
	}
	if (ch < 0) {
	return -1;
	}
}

int main() 
{
	const int r1 = 10, r2 = 10;	// r1 - это радиус первой окружноси, r2 - второй
	const int i_start = 5, j_start = 5, l_start = 4; /* объявим начальные положения по координатам i и j, а также значение динамического параметра движения соответственно (далее в каждой k+1-ой итерации они будут иметь значения k-ой итерации)*/
	
	int i_prvs = i_start; // сохраним значения констант в переменные,
	int j_prvs = j_start; // так как с каждым новым шагом
	int l_prvs = l_start; // значение предыдущего шага будет изменяться
	
	int count = 0; // будем считать кол-во попаданий
	int i1_crcl = -10, j1_crcl = -10, i2_crcl = -20, j2_crcl = -20; // сохраним значения координат i и j первой и второй окружности
	double i = 0, l = 0; // объявим переменные, которые будут иметь значения k+1-ой итерации, а также k - начало отсчета времени
	int j = 0, k = 1;
	
	
	for (k; k < 50; k++) { // цикл по каждому k-ому промежутку времени(k - значение промежутка времени)
		i = l_prvs / 3 - abs(i_prvs-k) * sign(l_prvs - j_prvs); // в соответствии с условием, обновляем значение i
		j = j_prvs % 10 - (max(i_prvs, j_prvs) % (k+1)); // в соответствии с условием, обновляем значение j
		l = i_prvs + (j_prvs * k) % 5 + l_prvs / 5 + 3; // в соответствии с условием, обновляем значение l
		
		i_prvs = i; // сохраняем в i_prvs значение k-ой итерации
		j_prvs = j; // сохраняем в j_prvs значение k-ой итерации
		l_prvs = l; // сохраняем в l_prvs значение k-ой итерации
		int len1_i = i - i1_crcl; // сохраним разность координат между i первого круга и i точки
		int len1_j = j - j1_crcl; // сохраним разность координат между j первого круга и j точки 
		int len2_i = i - i2_crcl; // сохраним разность координат между i второго круга и i точки 
		int len2_j = j - j2_crcl; // сохраним разность координат между j второго круга и j точки 
		
		if ((sqrt(len1_i * len1_i + len1_j * len1_j) <= r1) && (sqrt(len2_i * len2_i + len2_j * len2_j) <= r2))  { //если точка внутри обоих окружностей, вывод - попал
			printf("попадание:), i = %lf j = %d l = %lf k = %d\n", i, j, l, k);
			count += 1;
			}		
	}
	if (count == 0) { // иначе ни попал ни разу
		printf("промах:(, i = %lf j = %d l = %lf k = %d\n", i, j, l, k);
		}
	return 0;
}
